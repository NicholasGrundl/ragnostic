# Document Section Analysis Technical Specification

## Overview

This document outlines the technical approach for analyzing and extracting document sections from full-text content, combining hierarchical structure analysis, semantic understanding, and flexible section numbering across different document types.

## 1. Document Structure Analysis

### 1.1 Example Document Structure

Using Chapter 7: Aerobic Fermentation from a bioprocess engineering textbook as an example:

```text
Chapter 7: Aerobic Fermentation
[Chapter intro text about aerobic fermentation basics...]

7.1 Principles of Aerobic Fermentation
[Level 1 intro text about core concepts...]

    7.1.1 Oxygen Transfer Fundamentals
    [Level 2 text about oxygen transfer...]
    
        7.1.1.1 Gas-Liquid Mass Transfer
        [Level 3 text about mass transfer coefficients...]
```

### 1.2 Key Structural Properties

1. **Hierarchical Nesting**
   - Parent sections contain their intro text plus all subsection content
   - Clear parent-child relationships through numbering
   - Each level adds one number in the hierarchy
   - Sequence matters within each level

2. **Text Organization**
   - Sections may have intro text before subsections begin
   - Intro text belongs to the parent section
   - Content is hierarchically nested
   - Images and tables may appear within sections

## 2. Schema Design

### 2.1 Core Tables

```sql
-- Track section analysis attempts
CREATE TABLE section_analyses (
    analysis_id TEXT PRIMARY KEY,
    doc_id TEXT NOT NULL,
    doc_type TEXT NOT NULL DEFAULT 'unknown'
        CHECK (doc_type IN ('journal_article', 'trade_article', 'textbook', 'unknown')),
    method TEXT NOT NULL,
    parameters TEXT,              -- JSON of analysis parameters
    source_text TEXT NOT NULL,    -- Text used for analysis
    created_at DATETIME NOT NULL,
    FOREIGN KEY (doc_id) REFERENCES documents(id)
);

-- Track section hierarchy
CREATE TABLE document_sections (
    section_id TEXT PRIMARY KEY,
    analysis_id TEXT NOT NULL,
    section_number TEXT NOT NULL,     -- e.g., "7.1.1.2"
    section_type TEXT,                -- e.g., 'abstract', 'methods'
    level INTEGER NOT NULL,           -- 1, 2, 3, etc.
    title TEXT NOT NULL,
    intro_text TEXT,                  -- Text before subsections
    start_offset INTEGER NOT NULL,    -- Start in source_text
    end_offset INTEGER NOT NULL,      -- End in source_text
    sequence_order INTEGER NOT NULL,  -- Order within level
    FOREIGN KEY (analysis_id) REFERENCES section_analyses(analysis_id),
    CHECK (section_type IN (
        'abstract', 'introduction', 'methods', 'results', 
        'discussion', 'conclusions', 'references', NULL
    ))
);

-- Track section relationships explicitly
CREATE TABLE section_relationships (
    parent_section_id TEXT NOT NULL,
    child_section_id TEXT NOT NULL,
    PRIMARY KEY (parent_section_id, child_section_id),
    FOREIGN KEY (parent_section_id) REFERENCES document_sections(section_id),
    FOREIGN KEY (child_section_id) REFERENCES document_sections(section_id)
);
```

### 2.2 Key Column Analysis

#### intro_text
- Self-contained content before subsections
- Natural summary-level content
- Good candidate for section-level embeddings
- May be empty for leaf sections

#### sequence_order
- Integer-based for easy sorting
- Restarts at 1 for each parent section
- Independent of section numbering
- Preserves original document flow

#### section_number
- Encodes full hierarchical path
- Text format for flexibility
- Natural sort ordering
- Human readable

## 3. Section Numbering Implementation

### 3.1 Section Number Generator

```python
from enum import Enum
from typing import Optional

class DocumentType(str, Enum):
    """Types of documents supported by the system."""
    JOURNAL_ARTICLE = "journal_article"
    TRADE_ARTICLE = "trade_article"
    TEXTBOOK = "textbook"
    UNKNOWN = "unknown"

class SectionNumberGenerator:
    """Generates section numbers based on document type and structure."""
    
    def __init__(self, doc_type: DocumentType = DocumentType.UNKNOWN):
        self.doc_type = doc_type
        self.current_level = {0: 0, 1: 0, 2: 0}  # Track numbers at each level
        
    def get_next_number(self, 
                       level: int, 
                       title: str,
                       parent_number: Optional[str] = None) -> str:
        """Generate next section number based on context."""
        if self.doc_type == DocumentType.JOURNAL_ARTICLE:
            return self._get_journal_number(level, title)
        elif self.doc_type == DocumentType.TRADE_ARTICLE:
            return self._get_trade_number(level, title)
        else:  # TEXTBOOK or UNKNOWN
            return self._get_generic_number(level, parent_number)

    def _get_generic_number(self, 
                          level: int, 
                          parent_number: Optional[str] = None) -> str:
        """Generate generic hierarchical number."""
        # Reset lower levels
        for l in range(level + 1, max(self.current_level.keys()) + 1):
            self.current_level[l] = 0
            
        # Increment current level
        self.current_level[level] += 1
        
        if parent_number:
            return f"{parent_number}.{self.current_level[level]}"
        elif level == 0:
            return str(self.current_level[level])
        else:
            return f"{self.current_level[level]}"
```

## 4. Content Processing Functions

### 4.1 Section Content Extraction

```python
def get_section_content(section_id: str, include_subsections: bool = True) -> str:
    """Get section content with optional subsections."""
    section = db.get_section(section_id)
    analysis = db.get_analysis(section.analysis_id)
    
    if not include_subsections:
        # Return just this section's intro text
        return analysis.source_text[section.start_offset:section.end_offset]
    
    # Get all subsection content
    subsections = db.get_subsections(section_id)
    return _combine_section_content(section, subsections, analysis.source_text)

def get_content_by_level(analysis_id: str, max_level: int) -> str:
    """Get document content split to specified level."""
    analysis = db.get_analysis(analysis_id)
    sections = db.get_sections_by_level(analysis_id, max_level)
    return _render_sections_by_level(sections, analysis.source_text)
```

### 4.2 Hierarchical Embeddings

```python
def create_hierarchical_embeddings(section_id: str) -> dict:
    """Create embeddings at multiple levels."""
    section = db.get_section(section_id)
    
    embeddings = {
        # Level 1: Just intro text
        "intro": embed_text(section.intro_text),
        
        # Level 2: Intro + immediate subsection intros
        "summary": embed_text(_combine_with_subsection_intros(section)),
        
        # Level 3: Full content including subsections
        "full": embed_text(_get_full_content(section))
    }
    
    return embeddings
```

## 5. Search and Query Support

### 5.1 Hierarchical Section Queries

```sql
-- Get full section hierarchy
WITH RECURSIVE section_tree AS (
    -- Base case: start with top-level section
    SELECT 
        s.*, 
        0 as depth
    FROM document_sections s
    WHERE s.section_id = ?
    
    UNION ALL
    
    -- Recursive case: add children
    SELECT 
        c.*,
        st.depth + 1
    FROM section_tree st
    JOIN section_relationships r ON st.section_id = r.parent_section_id
    JOIN document_sections c ON r.child_section_id = c.section_id
)
SELECT * FROM section_tree
ORDER BY section_number;
```

### 5.2 Multi-Level Search Strategy

```python
async def search_sections(query: str) -> List[SearchResult]:
    """Multi-level section search."""
    # Level 1: Search section intros only
    intro_matches = await search_intros(query)
    if intro_matches:
        return intro_matches
        
    # Level 2: Search with subsection context
    subsection_matches = await search_with_context(query)
    if subsection_matches:
        return subsection_matches
        
    # Level 3: Full content search
    return await search_full_content(query)
```

## 6. Design Benefits

1. **Natural Summarization Levels**
   - intro_text provides ready-made summaries
   - section_number enables hierarchical rollup
   - sequence_order maintains document flow

2. **Flexible Document Support**
   - Adapts to different document types
   - Handles standard academic sections
   - Supports less formal structures

3. **Rich Context Management**
   - Full path available for each section
   - Order preserved within levels
   - Clear parent-child relationships

4. **Future Extensibility**
   - Easy to add new document types
   - Can enhance section type recognition
   - Supports custom numbering schemes